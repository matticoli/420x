<!doctype html>
<html lang='en'>
<head>
    <style>
    body { 
        margin:0 
    }

    .slider {
        position: relative; 
        top: 8px;
    }

    .slider-container {
        display: inline-block; 
        padding: 5px;
    }
    </style>
</head>
<body>
    <canvas id='gl'></canvas>
    <br/>
    <button onclick="getVideo()">Video</button>
    <button onclick="stopVideo()">Stop Video</button>
    
    <div class="slider-container">
        <label for="brightness">Invert</label>
        <input type="checkbox" id="invert">
    </div>
    <br />
    <div class="slider-container">
        <label for="exposure">Exposure</label>
        <input type="range" min="0" max="200" value="0" class="slider" id="exposure">
    </div>
    <br />
    <div class="slider-container">
        <label for="brightness">Brightness</label>
        <input type="range" min="-100" max="200" value="0" class="slider" id="brightness">
    </div>
    <br />
    <div class="slider-container">
        <label for="sinx">Sin X</label>
        <input type="range" min="-256" max="256" value="1" class="slider" id="sinx">
        <label for="xsync">Sync</label>
        <input type="checkbox" id="xsync" checked="true">
        <br />
        <label for="fx">Frequency X</label>
        <input type="range" min="1" max="10" value="1" class="slider" id="fx">
        <!-- <button onclick="document.getElementById('fx').value = 1">Zero</button> -->
    </div>
    <br />
    <div class="slider-container">
        <label for="siny">Sin Y</label>
        <input type="range" min="-256" max="256" value="1" class="slider" id="siny">
        <label for="ysync">Sync</label>
        <input type="checkbox" id="ysync" checked="true">
        <br />
        <label for="fy">Frequency Y</label>
        <input type="range" min="1" max="10" value="1" class="slider" id="fy">
    </div>
    <br />
</body>
<!-- vertex shader, as simple as possible -->
<script id='vertex' type='x-shader/x-vertex'>
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4( a_position, 0., 1. );
    }
</script>
<!-- fragment shader -->
<script id='fragment' type='x-shader/x-fragment'>
    #ifdef GL_ES
    precision mediump float;
    #endif
    uniform float time;
    uniform float brightness, exposure;
    uniform float sinx, siny, fx, fy;
    uniform float invert, xsync, ysync;
    uniform vec2 resolution;
    // GLSL gives us this for free... our first sampler2D automatically
    // points to our first bound texture.
    uniform sampler2D uSampler;
    
    void main() {
        // texture2D lets us lookup a pixel in a texture by passing xy values from 0â€“1
        // to get those normalized values we divide gl_FragCoord (measured in pixels) by our resolution
        vec2 p = gl_FragCoord.xy / resolution;
        vec2 offset = 1. / resolution;
        vec3 base = exposure * texture2D( uSampler, p).rgb;
        vec3 color = base + sin(p.x * sinx + ((fx * time) * xsync)) * sin(p.y * siny + ((fy + time) * ysync));

        vec4 final = vec4( vec3( (invert * brightness) + color), 1.);
        gl_FragColor = final;
        //vec3 lowerleft = texture2D( uSampler, gl_FragCoord.xy / resolution - offset).rgb;
        //vec3 upperright = texture2D( uSampler, gl_FragCoord.xy / resolution + offset).rgb;
        //gl_FragColor = vec4( vec3(brightness + invert + (0.01 + base + lowerleft * .325 + upperright * .325)), 1.);
        //gl_FragCoord = blur9( uSampler, gl_FragCoord.xy / resolution, resolution, vec2(2.) );
    }
</script>
<script type='text/javascript'>
    // "global" variables
    let gl, uTime, uBrightness, uExposure, uInvert, uX, uY, uXsyncx, uYsync, uFx, uFy, img, texture,textureLoaded = false, program
    window.onload = function() {
        const canvas = document.getElementById( 'gl' )
        gl = canvas.getContext( 'webgl' )
        canvas.width = 256
        canvas.height = 256
        img = document.createElement( 'img' )
        img.crossOrigin = 'Anonymous'
        // img.src = './cat.jpg'
        // getVideo();
        img.onload = makeTexture
        document.body.appendChild( img )
        // create our canvas
        greencanvas = document.createElement( 'canvas' )
        // get a drawing context for our canvas
        greenctx = greencanvas.getContext( '2d' )
        // set our painting color
        greenctx.fillStyle = 'green'
        // draw our rectangle... 350x150 are the default canvas dimensions
        greenctx.fillRect( 0,0,350,150 )
        greenctx.fillStyle = 'red'
        greenctx.fillRect( 125,50,50,50 )
        // put the canvas on the page
        // document.body.appendChild( greencanvas )
        // define drawing area of canvas. bottom corner, width / height
        gl.viewport( 0,0,gl.drawingBufferWidth, gl.drawingBufferHeight )
        // create a buffer object to store vertices
        const buffer = gl.createBuffer()
        // point buffer at graphic context's ARRAY_BUFFER
        gl.bindBuffer( gl.ARRAY_BUFFER, buffer )
        const triangles = new Float32Array([
        -1, -1,
        1,  -1,
        -1, 1,
        -1, 1,
        1, -1,
        1, 1
        ])
        // initialize memory for buffer and populate it. Give
        // open gl hint contents will not change dynamically.
        gl.bufferData( gl.ARRAY_BUFFER, triangles, gl.STATIC_DRAW )
        // create vertex shader
        let shaderScript = document.getElementById('vertex')
        let shaderSource = shaderScript.text
        const vertexShader = gl.createShader( gl.VERTEX_SHADER )
        gl.shaderSource( vertexShader, shaderSource );
        gl.compileShader( vertexShader )
        // create fragment shader
        shaderScript = document.getElementById('fragment')
        shaderSource = shaderScript.text
        const fragmentShader = gl.createShader( gl.FRAGMENT_SHADER )
        gl.shaderSource( fragmentShader, shaderSource );
        gl.compileShader( fragmentShader )
        console.log(gl.getShaderInfoLog(fragmentShader));
        // create shader program
        program = gl.createProgram()
        gl.attachShader( program, vertexShader )
        gl.attachShader( program, fragmentShader )
        gl.linkProgram( program )
        gl.useProgram( program )
        /* ALL ATTRIBUTE/UNIFORM INITIALIZATION MUST COME AFTER 
        CREATING/LINKING/USING THE SHADER PROGAM */
        // find a pointer to the uniform "time" in our fragment shader
        uTime = gl.getUniformLocation( program, 'time' ) 
        uBrightness = gl.getUniformLocation( program, 'brightness' ) 
        uExposure = gl.getUniformLocation( program, 'exposure' ) 
        uInvert = gl.getUniformLocation(program, 'invert')
        uX = gl.getUniformLocation(program, 'sinx')
        uY = gl.getUniformLocation(program, 'siny')
        uXsync = gl.getUniformLocation(program, 'xsync')
        uYsync = gl.getUniformLocation(program, 'ysync')
        uFx = gl.getUniformLocation(program, 'fx')
        uFy = gl.getUniformLocation(program, 'fy')
        const uRes = gl.getUniformLocation( program, 'resolution' )
        gl.uniform2f( uRes, gl.drawingBufferWidth, gl.drawingBufferHeight )
        // get position attribute location in shader
        const position = gl.getAttribLocation( program, 'a_position' )
        // enable the attribute
        gl.enableVertexAttribArray( position )
        // this will point to the vertices in the last bound array buffer.
        // In this example, we only use one array buffer, where we're storing 
        // our vertices
        gl.vertexAttribPointer( position, 2, gl.FLOAT, false, 0,0 )
        render()
    }

    let video

    function getVideo() {
        video = document.createElement( 'video' )
        navigator.mediaDevices.getUserMedia({
            video:true
        }).then( stream => { 
            video.srcObject = stream
            video.play()
            makeTexture()
        })
        return video
    }

    function stopVideo() {
        video.pause()
        textureLoaded = false
    }

    function makeTexture() {
        // create an OpenGL texture object
        texture = gl.createTexture()
        // this tells OpenGL which texture object to use for subsequent operations
        gl.bindTexture( gl.TEXTURE_2D, texture )
        // since canvas draws from the top and shaders draw from the bottom, we
        // have to flip our canvas when using it as a shader.
        gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true )
        // how to map when texture element is more than one pixel
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR )
        // how to map when texture element is less than one pixel
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR )
        // you must have these properties defined for the video texture to
        // work correctly
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE )
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE )
        // let our render loop know when the texture is ready
        textureLoaded = true;
    }
    // keep track of time via incremental frame counter
    let time = 0
    function render() {
        // schedules render to be called the next time the video card requests 
        // a frame of video
        window.requestAnimationFrame( render )
        if( textureLoaded === true ) {
            // send texture data to GPU    
            gl.texImage2D( 
            gl.TEXTURE_2D,    // target: you will always want gl.TEXTURE_2D
            0,                // level of detail: 0 is the base
            gl.RGBA, gl.RGBA, // color formats
            gl.UNSIGNED_BYTE, // type: the type of texture data; 0-255
            video             // pixel source: could also be video or image
            )
            // draw triangles using the array buffer from index 0 to 6 (6 is count)
            gl.drawArrays( gl.TRIANGLES, 0, 6 )
        } else {
            gl.texImage2D( 
            gl.TEXTURE_2D,    // target: you will always want gl.TEXTURE_2D
            0,                // level of detail: 0 is the base
            gl.RGBA, gl.RGBA, // color formats
            gl.UNSIGNED_BYTE, // type: the type of texture data; 0-255
            img             // pixel source: could also be video or image
            )
            gl.drawArrays( gl.TRIANGLES, 0, 6 )

        }
        // update time on CPU and GPU
        time++
        gl.uniform1f( uTime, time )

        // Pass control uniforms
        let brightness = document.getElementById("brightness").value / 100.0;
        let exposure = document.getElementById("exposure").value / 100.0;
        let x = document.getElementById('sinx').value;
        let y = document.getElementById('siny').value;
        let invert = document.getElementById('invert').checked;
        let xsync = document.getElementById('xsync').checked;
        let ysync = document.getElementById('ysync').checked;
        let fx = document.getElementById('fx').value;
        let fy = document.getElementById('fy').value;

        gl.uniform1f(uBrightness , brightness)
        gl.uniform1f(uExposure , exposure)
        gl.uniform1f(uInvert , invert ? -1.0 : 1.0)
        gl.uniform1f(uX , x)
        gl.uniform1f(uY , y)
        gl.uniform1f(uXsync , xsync ? 0.0 : 1.0)
        gl.uniform1f(uYsync , ysync ? 0.0 : 1.0)
        gl.uniform1f(uFx , fx)
        gl.uniform1f(uFy , fy)

        // draw triangles using the array buffer from index 0 to 6 (6 is count)
        gl.drawArrays( gl.TRIANGLES, 0, 6 )
    }
</script>
</html>